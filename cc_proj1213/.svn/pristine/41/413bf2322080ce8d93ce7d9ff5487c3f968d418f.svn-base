/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(DSL_LARA)package pack;public class DSL_LARA{  public static void main(String args []) throws ParseException  {    DSL_LARA myConverter = new DSL_LARA(System.in);    SimpleNode root = myConverter.Start();    root.dump("");  }}PARSER_END(DSL_LARA)SKIP :{  " "| "\t"| "\n"| "\r"| <    (      "//"    | "#"    | "%" (~[ "{" ]) //FODI ISTO TUDO    )    (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}< DEFAULT >TOKEN [ IGNORE_CASE ] :{  < RULE : "rule" >| < FOREACH : "foreach" >| < OR : "or" >| < AND : "and" >| < XOR : "xor" >| < EACH : "each" >| < DO : "do" >| < STMT : "statement" >| < END : "end" >| < BEGIN : "begin" >| < KEY : "key" >| < TAG : "tag" >| < VAR : "var" >| < SET : "set" >| < MAX : "max" >| < MIN : "min" >| < WITH : "with" >| < IN : "in" >| < WRAP : "wrap" >| < FLOOR : "floor" >| < OVERFLOW : "overflow" >| < ROUND : "round" >| < COMMUTATIVE : "commutative" >| < IR : "ir" >| < OPERATION : "operation" >| < USE : "use" >| < ELSE : "else" >| < LHS : "lhs" >| < CALL : "call" >| < CONFIGURATION : "configuration" >| < IF : "if" >| < INSERT : "insert" >| < BEFORE : "before" >| < AFTER : "after" >| < FLOAT : "float" >| < INT : "int" >| < AROUND : "around" >| < APPLY : "apply" >| < DEPENDENT : "dependent" >| < FPRINTF : "fprintf" >| < PRINT : "print" >| < WARNING : "warning" >| < SCREEN : "screen" >| < FILE : "file" >| < FUNCTION : "function" >| < MODULE : "module" >| < PROGRAM : "program" >| < TYPEDEF : "typedef" >| < FIXED : "fixed" >| < DOUBLE : "double" >| < SINGLE : "single" >| < INT8 : "int8" >| < INT16 : "int16" >| < INT32 : "int32" >| < UINT8 : "uint8" >| < UINT16 : "uint16" >| < UINT32 : "uint32" >| < CHAR : "char" >| < BOOL : "bool" >| < DECOMPOSE : "decompose" >| < TARGETCODE :    "%{"    (      ~[ "}" ]    | "}" ~[ "%" ]    )*    "}%" >}< DEFAULT >TOKEN :{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < QUOTED :    "\'"    (      ~[ "\'" ]    | "\\\'"    )+    "\'" >| < NUMBER : (< DIGIT >)+ >| < STRING :    "\""    (      ~[ "\"" ]    | "\\\""    )+    "\"" >}SimpleNode Start() :{}{  (    < APPLY > < IDENTIFIER > (":" < IDENTIFIER >)* ";"  )*  (    Rule()  )*  {    return jjtThis;  }}void Rule() :{  Token t;}{  < RULE > t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  (    Use()  )*  (    Statement()  | InjectCode()  | TypeDef()  )*  (    DataTypeConvRules()  )*  < END >}void Use() :{}{  < USE > < IDENTIFIER > ";"}void Statement() #void :{}{  ForEachStatement()| Insert()| Set()| WithStatement() //Diogo pergunta: deixamos os nomes destes statements, mudamos os nomes ou tiramos e pomos só statement genérico??? }void InjectCode() #IfStatement :{  Token t, u, v;}{  < IF > u = < IDENTIFIER > ":" v = < IDENTIFIER >  (    t = "<"  | t = ">"  | t = "<="  | t = ">="  )  {    jjtThis.val = u.image;  }  #Left  {    jjtThis.val = v.image;  }  #Right  {}  #LeftOp(2)Number() #RightOp{  jjtThis.val = t.image;}#Condition(2)(  TargetCode())+#Body < END >}void TypeDef():{  Token t;}{  < TYPEDEF > t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  "=" Types() ";"}void DataTypeConvRules() :{Token t;}{  (< COMMUTATIVE > #Comutative)? < OPERATION > OpsForConvRules() (TypesOnCOnvRules()  (    < LHS > #Lhs  | t = < IDENTIFIER >  {	jjtThis.val = t.image;
  } #Ident  )) #Args  "::=" ( ("(" (TypesOnCOnvRules()    (    < IR > #Ir  | t = < IDENTIFIER >  {
    jjtThis.val = t.image;  } #Ident  )) #Type  ")") #Brackets {}
  
  (    ("[" (TypesOnCOnvRules() t = < IDENTIFIER >    {		jjtThis.val = t.image;
    } #Ident ) #Type    {}  (    "," (TypesOnCOnvRules() t = < IDENTIFIER > 
    {
		jjtThis.val = t.image;
    } #Ident ) #Type    {}  )?)  "]") #SquareBrackets ) #TempVars ":"  (    IfConvRule()  | SimpleStatement()  )+ #Rules  < END >}void ForEachStatement() :{  Token t;}{  (    < FOREACH >    {      int argCounter = 1;    }    (      < KEY > #Key    | < TAG > #Tag    | < VAR > #Var)    (t = < IDENTIFIER >    {      jjtThis.val = t.image;      argCounter++;    }    #Elem)? #Iter(argCounter)  < IN >  (    (      < IDENTIFIER >    |      (        (          < PROGRAM > #Program        | < FUNCTION > #Function)        (          "=" SetOfJPs() #Equals)?      )      (        ":" SetOfJPs() #Colons)?    )?    (      "{" JPList() #List "}")?  ) #IterList < DO >  {    int instCounter = 0;  }  ((Insert()| Set()) (< DEPENDENT > ":" (DependentStmt()) + < END >) ?)+#Body < END >)}void Insert() :{}{  < INSERT > "."  (    < BEFORE > #Before  | < AFTER > #After  | < AROUND > #Around)  {    int argCounter = 1;  }  (    "."    (      < END > #End    | < BEGIN > #Begin)    {      argCounter++;    }  )?  #Args(argCounter)":"(  TargetCode() #Body)+}void Set() #void :{  Token t;}{  < SET >  (    (      t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Lhs "=" (("{" Identifier() ("," Identifier()) * "}")    | Types()    | t = < IDENTIFIER >      {        jjtThis.val = t.image;      }    ) #Rhs) #Set| (< FIXED > "=" "{" FixedPointProperties() "=" ValuesFixedPointProperties() #Set(2) ("," FixedPointProperties() "=" ValuesFixedPointProperties() #Set(2)) * "}") #SetFixed)";"}void WithStatement() :{  Token t;}{  < WITH >  (    (      (        (          < FUNCTION > "=" t = < IDENTIFIER >          {            jjtThis.val = t.image;          }          #Function        | < MODULE > "=" t = < IDENTIFIER >          {            jjtThis.val = t.image;          }          #Module)      )      (        (          < DO >          (            Statement()            (              < DEPENDENT > ":"              (                DependentStmt()              )+              < END >            )?          )+          #Do < END >)      |        (          (            ","            (              (< CALL > "=" t = < IDENTIFIER >)              {                jjtThis.val = t.image;              }              #Call            | (< OPERATION > "=" OpsForConfigRules()) #Operation)        )?        (          < USE > (< CONFIGURATION > t = < IDENTIFIER >          {            jjtThis.val = t.image;          }          #Config ";")+ < END >        ) #Use)    )  )|  (    < STMT > "=" t = < STRING >    {      jjtThis.val = t.image;    }    #Statement < DO > Decompose() #Do < END >)|(  < VAR > "=" SetOfJPs() #Var < DO > (Statement())+#Do < END >))}void TargetCode() #void :{  Token t, s = null;}{  < TARGETCODE > #Targetcode| < FPRINTF > "(" Arg(){  int argCounter = 1;}(  "," Arg()  {    argCounter++;  })*")" ";" #Fprintf(argCounter)| t = < IDENTIFIER >(  (    Param()    {      jjtThis.val = t.image;    }    "="    (      (        < IDENTIFIER > Param()        {          jjtThis.val = t.image;        }        s = Op() t = < NUMBER >        {          jjtThis.val = t.image;        }        #Number)      {        jjtThis.val = s.image;      }      #Op(2)    ";"  | (t = < NUMBER >)    {      jjtThis.val = t.image;    }    #Number ";")) #Assignment(2)|{  argCounter = 0;}(  "("  (    {      argCounter++;    }    Arg()    (      "," Arg()      {        argCounter++;      }    )*  )?  ")" ";"){  jjtThis.val = t.image;}#Method(argCounter))| < PRINT > "("{  argCounter = 2;}(  < SCREEN > #Screen| (< FILE > ":" ((t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Lhs "." t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Rhs) #FileId(2)| (t = < QUOTED >)  {    jjtThis.val = t.image;  }  #Quoted)) #File(1))"," Arg()(  "," Arg()  {    argCounter++;  })*")" ";" #Print(argCounter)| < WARNING > "(" t = < QUOTED > ")" ";"{  jjtThis.val = t.image;}#Warning}void Arg() #void :{  Token t;}{  t = < NUMBER >  {    jjtThis.val = t.image;  }  #Arg| < IDENTIFIER > (Param())?#Arg| t = < QUOTED > (Param() ":" < QUOTED >)?{  jjtThis.val = t.image;}#Arg| Param(){  int counter = 1;}(":" t = < QUOTED >{  jjtThis.val = t.image;  counter = 2;}#Colons)? #Arg(counter)| "\'" Param(){  counter = 1;}(":" t = < QUOTED >{  jjtThis.val = t.image;  counter = 2;}#Colons)? "\'" #Arg(counter)}void Param() :{  Token t1, t2 = null;}{  "<"  (    < KEY > #Key  | t1 = < IDENTIFIER >    {      jjtThis.val = t1.image;    }    #Identifier  | < VAR > #Var)  ("." t2 = < IDENTIFIER >  {    jjtThis.val = t2.image;  }  #Rhs)? ">"}Token Op() #void :{  Token t;}{  t = "+"  {    return t;  }| t = "-"  {    return t;  }}void Types() #void :{}{  < INT8 > #Int8| < INT16 > #Int16| < INT32 > #Int32| < UINT8 > #UInt8| < UINT16 > #UInt16| < UINT32 > #UInt32| < CHAR > #Char| < BOOL > #Bool| < DOUBLE > #Double| < SINGLE > #Single| Fixed()}void OpsForConvRules() #void :{  Token t;}{  t = < STRING >  {    jjtThis.val = t.image;  }  #Operation}void TypesOnCOnvRules() #void :{}{  (    Types()  | < FLOAT > #Float  | < INT > #Int)}void IfConvRule() #If:{Token t; }{  < IF > ("("  (    < LHS > #Lhs  | CompleteIdentifier()  ) #LeftOp  {}  (    t = ">="  | t = "<="  | t = ">"  | t = "<"  | t = "=="  | t = "!="  )  (    CompleteIdentifier()  | BuiltInFunctions() "("    (      CompleteIdentifier()      (        "," CompleteIdentifier()      )*    )?    ")"  ) #RightOp  ")" )  {	jjtThis.val = t.image;
  } #Condition(2)  (    SimpleStatement()  | IfConvRule()  )+ #Body  {}  (    < ELSE >    (      SimpleStatement()    | IfConvRule()    )+ #Else  )?  < END >}void SimpleStatement() #void:{}{  (    < IR > "="    (      < LHS > #Lhs    | BuiltInFunctions() "("      (        CompleteIdentifier()        (          "," CompleteIdentifier()        )*      )?      ")"    | CompleteIdentifier()    )    ";"  ) #Ir|  (    CompleteIdentifier() #LeftOp "="    (      (      CompleteIdentifier()    | BuiltInFunctions() "("      (        CompleteIdentifier()        (          "," CompleteIdentifier()        )*      )?      ")"    )    (      (        < OR > #Or      | < AND > #And      | < XOR > #Xor      | "*" #Mul      | "+" #Sum      | "-" #Sub      )      (        CompleteIdentifier()      | BuiltInFunctions() "("        (          CompleteIdentifier()          (            "," CompleteIdentifier()          )*        )?        ")"      )    )?) #RightOp    ";"  ) #Assignment}void FixedPointProperties() #void :{}{  < OVERFLOW > #Overflow| < ROUND > #Round}void ValuesFixedPointProperties() #void :{}{  < WRAP > #Wrap| < FLOOR > #Floor}void SetOfJPs() #void :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Elem| ("{" (Identifier() ("," Identifier()) *) "}")}void Identifier() #void :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Elem}void JPList() #void :{}{  JP()  (    "," JP()  )*}void JP() #void :{  Token t;}{  (    (      ("@")? t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Elem)  | < END > #End  | < IF > #If  | < ELSE > #Else)}void DependentStmt() :{  Token t;}{  < FOREACH >  {    int argCounter = 1;  }  (    < KEY > #Key  | < TAG > #Tag  | < VAR > #Var)  (t = < IDENTIFIER >  {    jjtThis.val = t.image;    argCounter++;  }  #Elem)? #Iter(argCounter)< IN >(  (    < IDENTIFIER >  |    (      (        < PROGRAM > #Program      | < FUNCTION > #Function)      (":" t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Colons)?    )  )| "{" JPList() #List "}") #IterList < DO > ((Insert()| Set()) +)< END >}void OpsForConfigRules() #void :{  Token t;}{  t = < STRING >  {    jjtThis.val = t.image;  }  #OpsConfigRules}void Decompose():{  Token t;}{  < DECOMPOSE > t = < TARGETCODE >  {    jjtThis.val = t.image;  }  #TargetCode ";"}void Fixed():{}{  < FIXED >  (    "<" Number() "," Number() "," Number() ">"  )?}void Number() :{  Token t;}{  t = < NUMBER >  {    jjtThis.val = t.image;  }}void CompleteIdentifier() #Ident:{Token t;}{  t = < IDENTIFIER >  {    jjtThis.val = t.image;
  } #Left {}  (    "."    (      t = < IDENTIFIER >      {		jjtThis.val = t.image;
      } #Right    | BuiltInFunctions() #Right    )     {}  )?}void BuiltInFunctions() #void:{}{  < MAX > #Max| < MIN > #Min}