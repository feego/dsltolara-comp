/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(Calculator)package pack;public class Calculator{  public static void main(String args []) throws ParseException  {    Calculator myCalc = new Calculator(System.in);    SimpleNode root = myCalc.Start();    root.dump("");    System.out.println("Valor da expressão: " + myCalc.eval(root));  }  int eval(SimpleNode node)  {    if (node.jjtGetNumChildren() == 0)  // leaf node with integer value
    return node.val;    else if (node.jjtGetNumChildren() == 1)  // only one child
    return this.eval((SimpleNode) node.jjtGetChild(0));    SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
    SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child
    switch (node.id)    {      case CalculatorTreeConstants.JJTADD : return eval(lhs) + eval(rhs);      case CalculatorTreeConstants.JJTSUB : return eval(lhs) - eval(rhs);      case CalculatorTreeConstants.JJTMUL : return eval(lhs) * eval(rhs);      case CalculatorTreeConstants.JJTDIV : return eval(lhs) / eval(rhs);      default : // abort
      System.out.println("Operador ilegal!");      System.exit(1);    }    return 0;  }}PARSER_END(Calculator)SKIP :{  " "| "\t"| "\n"| "\r"| <    (      "//"    | "#"    | "%"    )    (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}< DEFAULT >TOKEN [ IGNORE_CASE ] :{  < RULE : "rule" >| < FOREACH : "foreach" >| < OR : "or" >| < AND : "and" >| < XOR : "xor" >| < EACH : "each" >| < DO : "do" >| < STMT : "statement" >| < END : "end" >| < BEGIN : "begin" >| < KEY : "key" >| < TAG : "tag" >| < VAR : "var" >| < SET : "set" >| < MAX : "max" >| < MIN : "min" >| < WITH : "with" >| < IN : "in" >| < WRAP : "wrap" >| < FLOOR : "floor" >| < OVERFLOW : "overflow" >| < ROUND : "round" >| < COMMUTATIVE : "commutative" >| < IR : "ir" >| < OPERATION : "operation" >| < USE : "use" >| < ELSE : "else" >| < LHS : "lhs" >| < CALL : "call" >| < CONFIGURATION : "configuration" >| < IF : "if" >| < INSERT : "insert" >| < BEFORE : "before" >| < AFTER : "after" >| < FLOAT : "float" >| < INT : "int" >| < AROUND : "around" >| < APPLY : "apply" >| < DEPENDENT : "dependent" >| < FPRINTF : "fprintf" >| < PRINT : "print" >| < WARNING : "warning" >| < SCREEN : "screen" >| < FILE : "file" >| < FUNCTION : "function" >| < MODULE : "module" >| < PROGRAM : "program" >| < TYPEDEF : "typedef" >| < FIXED : "fixed" >| < DOUBLE : "double" >| < SINGLE : "single" >| < INT8 : "int8" >| < INT16 : "int16" >| < INT32 : "int32" >| < UINT8 : "uint8" >| < UINT16 : "uint16" >| < UINT32 : "uint32" >| < CHAR : "char" >| < BOOL : "bool" >| < DECOMPOSE : "decompose" >| < TARGETCODE :    "%{"    (      ~[ "}" ]    | "}" ~[ "%" ]    )*    "}%" >}< DEFAULT >TOKEN :{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < QUOTED :    "\'"    (      ~[ "\'" ]    | "\\\'"    )+    "\'" >| < NUMBER : (< DIGIT >)+ >| < STRING :    "\""    (      ~[ "\"" ]    | "\\\""    )+    "\"" >}SimpleNode Start() :{}{  (    < APPLY > < IDENTIFIER > (":" < IDENTIFIER >)* ";"  )*  (    Rule()  )*  {    return jjtThis;  }}void Rule() :{}{  < RULE > < IDENTIFIER >  (    Use()  )*  (    Statement()  | InjectCode()  | TypeDef()  )*  (    DataTypeConvRules()  )*  < END >}void Use() :{}{  < USE > < IDENTIFIER > ";"}void Statement() :{}{  ForEachStatement()| Insert()| Set()| WithStatement()}void InjectCode() :{}{  < IF > < IDENTIFIER > ":" < IDENTIFIER >  (    "<"  | ">"  | "<="  | ">="  )  < NUMBER >  (    TargetCode()  )+  < END >}void TypeDef() :{}{  < TYPEDEF > < IDENTIFIER > "=" Types() ";"}void DataTypeConvRules() :{}{  (< COMMUTATIVE >)? < OPERATION > OpsForConvRules() TypesOnCOnvRules()  (    < LHS >  | < IDENTIFIER >  )  "::=" "(" TypesOnCOnvRules()  (    < IR >  | < IDENTIFIER >  )  ")" "[" TypesOnCOnvRules() < IDENTIFIER >  (    "," TypesOnCOnvRules() < IDENTIFIER >  )?  "]" ":"  (    IfConvRule()  | SimpleStatement()  )+  < END >}void ForEachStatement() :{}{  (    < FOREACH >    (      < KEY >    | < TAG >    | < VAR >    )    (< IDENTIFIER >)? < IN >    (      (        < IDENTIFIER >      |        (          (            < PROGRAM >          | < FUNCTION >          )          (            "=" SetOfJPs()          )?        )        (          ":" SetOfJPs()        )?      )?      (        "{" JPList() "}"      )?    )    < DO >    (      (        Insert()      | Set()      )      (        < DEPENDENT > ":"        (          DependentStmt()        )+        < END >      )?    )+    < END >  )}void Insert() :{}{  < INSERT > "."  (    < BEFORE >  | < AFTER >  | < AROUND >  )  (    "."    (      < END >    | < BEGIN >    )  )?  ":"  (    TargetCode()  )+}void Set() :{}{  < SET >  (    (      < IDENTIFIER > "="      (        (          "{" < IDENTIFIER > ("," < IDENTIFIER >)* "}"        )      | Types()      | < IDENTIFIER >      )    )  |    (      < FIXED > "=" "{" FixedPointProperties() "=" ValuesFixedPointProperties()      (        "," FixedPointProperties() "=" ValuesFixedPointProperties()      )*      "}"    )  )  ";"}void WithStatement() :{}{  < WITH >  (    (      (        (          < FUNCTION >        | < MODULE >        )        "=" < IDENTIFIER >      )      (        (          < DO >          (            Statement()            (              < DEPENDENT > ":"              (                DependentStmt()              )+              < END >            )?          )+          < END >        )      |        (          (            ","            (              (< CALL > "=" < IDENTIFIER >)            |              (                < OPERATION > "=" OpsForConfigRules()              )            )          )?          (            < USE > (< CONFIGURATION > < IDENTIFIER > ";")+ < END >          )        )      )    )  |    (      < STMT > "=" < STRING > < DO > Decompose() < END >    )  |    (      < VAR > "=" SetOfJPs() < DO >      (        Statement()      )+      < END >    )  )}void TargetCode() :{}{  < TARGETCODE >| < FPRINTF > "(" Arg()  (    "," Arg()  )*  ")" ";"| < IDENTIFIER >  (    (      Param() "="      (        (          < IDENTIFIER > Param() Op() < NUMBER >        )        ";"      | (< NUMBER >) ";"      )    )  |    (      "("      (        Arg()        (          "," Arg()        )*      )?      ")" ";"    )  )| < PRINT > "("  (    < SCREEN >  |    (      < FILE > ":"      (        (< IDENTIFIER > "." < IDENTIFIER >)      | (< QUOTED >)      )    )  )  "," Arg()  (    "," Arg()  )*  ")" ";"| < WARNING > "(" < QUOTED > ")" ";"}void Arg() :{}{  < NUMBER >| < IDENTIFIER >  (    Param()  )?| < QUOTED >  (    Param() ":" < QUOTED >  )?| Param() (":" < QUOTED >)?| "\'" Param() (":" < QUOTED >)? "\'"}void Param() :{}{  "<"  (    < KEY >  | < IDENTIFIER >  | < VAR >  )  ("." < IDENTIFIER >)? ">"}void Op() :{}{  "+"| "-"}void Types() :{}{  < INT8 >| < INT16 >| < INT32 >| < UINT8 >| < UINT16 >| < UINT32 >| < CHAR >| < BOOL >| < DOUBLE >| < SINGLE >| Fixed()}void OpsForConvRules() :{}{  < STRING >}void TypesOnCOnvRules() :{}{  (    Types()  | < FLOAT >  | < INT >  )}void IfConvRule() :{}{  < IF > "("  (    < LHS >  | CompleteIdentifier()  )  (    ">="  | "<="  | ">"  | "<"  | "=="  | "!="  )  (    CompleteIdentifier()  | BuiltInFunctions() "("    (      CompleteIdentifier()      (        "," CompleteIdentifier()      )*    )?    ")"  )  ")"  (    SimpleStatement()  | IfConvRule()  )+  (    < ELSE >    (      SimpleStatement()    | IfConvRule()    )+  )?  < END >}void SimpleStatement() :{}{  (    < IR > "="    (      < LHS >    | BuiltInFunctions() "("      (        CompleteIdentifier()        (          "," CompleteIdentifier()        )*      )?      ")"    | CompleteIdentifier()    )    ";"  )|  (    CompleteIdentifier() "="    (      CompleteIdentifier()    | BuiltInFunctions() "("      (        CompleteIdentifier()        (          "," CompleteIdentifier()        )*      )?      ")"    )    (      (        < OR >      | < AND >      | < XOR >      | "*"      | "+"      | "-"      )      (        CompleteIdentifier()      | BuiltInFunctions() "("        (          CompleteIdentifier()          (            "," CompleteIdentifier()          )*        )?        ")"      )    )?    ";"  )}void FixedPointProperties() :{}{  < OVERFLOW >| < ROUND >}void ValuesFixedPointProperties() :{}{  < WRAP >|   < FLOOR >}void SetOfJPs() :{}{  < IDENTIFIER >|  (    "{"    (      < IDENTIFIER > ("," < IDENTIFIER >)*    )    "}"  )}void JPList() :{}{  (    (      ("@")? < IDENTIFIER >    )  | < END >  | < IF >  | < ELSE >  )  (    ","    (      (        ("@")? < IDENTIFIER >      )    | < END >    | < IF >    | < ELSE >    )  )*}void DependentStmt() :{}{  < FOREACH >  (    < KEY >  | < TAG >  | < VAR >  )  (< IDENTIFIER >)? < IN >  (    (      < IDENTIFIER >    |      (        (          < PROGRAM >        | < FUNCTION >        )        (":" < IDENTIFIER >)?      )    )  | "{" JPList() "}"  )  < DO >  (    (      Insert()    | Set()    )+  )  < END >}void OpsForConfigRules() :{}{  < STRING >}void Decompose() :{}{  < DECOMPOSE > < TARGETCODE > ";"}void Fixed() :{}{  < FIXED > ("<" < NUMBER > "," < NUMBER > "," < NUMBER > ">")?}void CompleteIdentifier() :{}{  < IDENTIFIER >  (    "."    (      < IDENTIFIER >    | BuiltInFunctions()    )  )?}void BuiltInFunctions() :{}{  < MAX >| < MIN >}SimpleNode Expression() :{}{  Expr1()  {    return jjtThis;  }}void Expr1() #void :{}{  Expr2(1)  [    (      "+" Expr2(1) #Add(2)  | "-" Expr2(1) #Sub(2))]}void Expr2(int sign) #void :{}{  Expr3(sign)  (    "*" Expr3(1) #Mul(2)| "/" Expr3(1) #Div(2))?}void Expr3(int sign) #void :{  Token t;}{  t = < NUMBER >  {    jjtThis.val = sign * Integer.parseInt(t.image);  }  #Term| "-" Expr3(- 1)| "(" Expr1() ")"}
