/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(DSL_LARA)package pack;import java.util.ArrayList;import java.util.HashMap;public class DSL_LARA{  public static void main(String args []) throws ParseException  {    DSL_LARA myConverter = new DSL_LARA(System.in);    SimpleNode root = myConverter.Start();    //root.dump("");    //myConverter.createSymbolTable(root);    //myConverter.doSemanticAnalysis();
    System.out.println(new Converter().doConversion(root));  }  SymbolTable symbolTable = new SymbolTable();  /*
   * Variables used to create the symbol table
   */  String parsingRule = "";  boolean parsingSetType = false;  boolean parsingSet = false;  boolean parsingForEachStatement = false;  boolean parsingIter = false;  boolean parsingTag = false;  ArrayList < ArrayList < String >> forEachStatements = new ArrayList < ArrayList < String >> ();  ArrayList < ArrayList < String >> forEachUsedVars = new ArrayList < ArrayList < String >> ();  int forDepth = 0;  void doSemanticAnalysis()  {    for (String rule : symbolTable.getApplyList())    {      if (!symbolTable.containsRule(rule))      {        System.out.println(" ! Rule '" + rule + "' was applied and not declared");      }    }    for (String rule : symbolTable.getUseList())    {      if (!symbolTable.containsRule(rule))      {        System.out.println(" ! Rule '" + rule + "' was used and not declared");      }    }    HashMap < String, RuleSymbolTable > ruleMap = symbolTable.getRules();    for (String rule : ruleMap.keySet())    {
      /*
       * Sets
       */      for (String set : ruleMap.get(rule).getUsedSets())      {        if (!ruleMap.get(rule).containsSet(set))        {          System.out.println(" ! Set '" + set + "' was used without being declared on rule '" + rule + "'");        }      }
	  /*
       * SetTypes
       */
      for (String typedef : ruleMap.get(rule).getSetTypes())
      {
        if (!ruleMap.get(rule).containsTypeDef(typedef))
        {
          System.out.println(" ! TypeDef '" + typedef + "' was not declared on rule '" + rule + "'");
        }
      }
	  /*
       * Vars in ForEach statements
       */

      for (int i = 0; i < ruleMap.get(rule).getForEachsUsedVars().size(); i++)
      {
        ArrayList<ArrayList <String >> statement = ruleMap.get(rule).getForEachsUsedVars().get(i);

        for (ArrayList < String > varList : statement)        {			for (String var : varList)			{				if (!ruleMap.get(rule).containsForDeclared(i, var))
				{					System.out.println(" ! Identifier '" + var + "' not defined on rule '" + rule + "'");
				}
			}
        }
      }    }  }  void createSymbolTable(SimpleNode node)  {    if (parsingForEachStatement && node.toString() == "Identifier")    {      forEachUsedVars.get(forEachStatements.size() - 1).add(node.val);    }    if (parsingSetType)    {      if (node.val != null) symbolTable.addSetType(parsingRule, node.val);      parsingSetType = false;    }    else if (parsingIter)    {      parsingTag = true;      parsingIter = false;    }    else if (parsingTag)    {      parsingTag = false;      if (node.val != null && node.toString() == "Elem") forEachStatements.get(forEachStatements.size() - 1).add(node.val);    }    switch (node.toString())    {      case "Apply" : symbolTable.addApplyRule(node.val);      break;      case "Rule" : symbolTable.addRule(node.val);      parsingRule = node.val;      break;      case "Use" : if (node.val != null)      {        symbolTable.addUse(node.val);      }      break;      case "TypeDef" : symbolTable.addTypeDef(parsingRule, node.val);      break;      case "Set" : parsingSet = true;      break;      case "Lhs" : if (parsingSet)      {        if (node.val.equals("type")) parsingSetType = true;        else symbolTable.addSet(parsingRule, node.val);        parsingSet = false;      }      break;      case "IterList" : if (node.val != null) symbolTable.addUsedSet(parsingRule, node.val);      break;      case "ForEachStatement" : forEachStatements.add(new ArrayList < String > ());      forEachUsedVars.add(new ArrayList < String > ());      forDepth++;      parsingForEachStatement = true;      break;      case "DependentStmt" : forEachStatements.add(new ArrayList < String > ());      forEachUsedVars.add(new ArrayList < String > ());      forDepth++;      parsingForEachStatement = true;      case "Iter" : if (parsingForEachStatement) parsingIter = true;      break;    }    for (int i = 0; i < node.jjtGetNumChildren(); ++i)    {      SimpleNode n = (SimpleNode) node.jjtGetChild(i);      if (n != null)      {        createSymbolTable(n);      }    }    // adicionar variaveis do foreach à symbol table
    if ((node.toString() == "ForEachStatement" || node.toString() == "DependentStmt") && forDepth > 0)    {      forDepth--;      if (forDepth == 0)      {        symbolTable.addForEachsDeclared(parsingRule, forEachStatements);        symbolTable.addForEachsUsed(parsingRule, forEachUsedVars);        parsingForEachStatement = false;        forEachStatements = new ArrayList < ArrayList < String >> ();        forEachUsedVars = new ArrayList < ArrayList < String >> ();      }    }  }  String eval(SimpleNode node)  {    return "";  }}PARSER_END(DSL_LARA)SKIP :{  " "| "\t"| "\n"| "\r"| <    (      "//"    | "#"    | "%" (~[ "{" ]) //FODI ISTO TUDO    )    (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}< DEFAULT >TOKEN [ IGNORE_CASE ] :{  < RULE : "rule" >| < FOREACH : "foreach" >| < OR : "or" >| < AND : "and" >| < XOR : "xor" >| < EACH : "each" >| < DO : "do" >| < STMT : "statement" >| < END : "end" >| < BEGIN : "begin" >| < KEY : "key" >| < TAG : "tag" >| < VAR : "var" >| < SET : "set" >| < MAX : "max" >| < MIN : "min" >| < WITH : "with" >| < IN : "in" >| < WRAP : "wrap" >| < FLOOR : "floor" >| < OVERFLOW : "overflow" >| < ROUND : "round" >| < COMMUTATIVE : "commutative" >| < IR : "ir" >| < OPERATION : "operation" >| < USE : "use" >| < ELSE : "else" >| < LHS : "lhs" >| < CALL : "call" >| < CONFIGURATION : "configuration" >| < IF : "if" >| < INSERT : "insert" >| < BEFORE : "before" >| < AFTER : "after" >| < FLOAT : "float" >| < INT : "int" >| < AROUND : "around" >| < APPLY : "apply" >| < DEPENDENT : "dependent" >| < FPRINTF : "fprintf" >| < PRINT : "print" >| < WARNING : "warning" >| < SCREEN : "screen" >| < FILE : "file" >| < FUNCTION : "function" >| < MODULE : "module" >| < PROGRAM : "program" >| < TYPEDEF : "typedef" >| < FIXED : "fixed" >| < DOUBLE : "double" >| < SINGLE : "single" >| < INT8 : "int8" >| < INT16 : "int16" >| < INT32 : "int32" >| < UINT8 : "uint8" >| < UINT16 : "uint16" >| < UINT32 : "uint32" >| < CHAR : "char" >| < BOOL : "bool" >| < DECOMPOSE : "decompose" >| < TARGETCODE :    "%{"    (      ~[ "}" ]    | "}" ~[ "%" ]    )*    "}%" >}< DEFAULT >TOKEN :{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < QUOTED :    "\'"    (      ~[ "\'" ]    | "\\\'"    )+    "\'" >| < NUMBER : (< DIGIT >)+ >| < STRING :    "\""    (      ~[ "\"" ]    | "\\\""    )+    "\"" >}SimpleNode Start() :{  Token t;}{  (    < APPLY > t = < IDENTIFIER >    {      jjtThis.val = t.image;    }    #Apply    {}    (":" t = < IDENTIFIER >    {      jjtThis.val = t.image;    }    #Apply)*  ";")*(  Rule())*{  return jjtThis;}}void Rule() :{  Token t;}{  < RULE > t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  (    Use()  )*  (    Statement()  | InjectCode()  | TypeDef()  )*  (    DataTypeConvRules()  )*  < END >}void Use() #void :{  Token t;}{  < USE > t = < IDENTIFIER > ";"  {    jjtThis.val = t.image;  }  #Use}void Statement() #void :{}{  ForEachStatement()| Insert()| Set()| WithStatement()
}void InjectCode() #IfStatement :{  Token t, u, v;}{  < IF > u = < IDENTIFIER > ":" v = < IDENTIFIER >  (    t = "<"  | t = ">"  | t = "<="  | t = ">="  )  {    jjtThis.val = u.image;  }  #Left  {    jjtThis.val = v.image;  }  #Right  {}  #LeftOp(2)Number() #RightOp{  jjtThis.val = t.image;}#Condition(2)(  TargetCode())+#Body < END >}void TypeDef():{  Token t;}{  < TYPEDEF > t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  "=" Types() ";"}void DataTypeConvRules() :{  Token t;}{  (< COMMUTATIVE > #Comutative)? < OPERATION > OpsForConvRules()  (    TypesOnCOnvRules()    (      < LHS > #Lhs    | t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Ident)  ) #Args "::=" (("(" (TypesOnCOnvRules() (< IR > #Ir| t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Ident)) #Type ")") #Brackets  {}  (("[" (TypesOnCOnvRules() t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Ident) #Type  {}  ("," (TypesOnCOnvRules() t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Ident) #Type  {}  ) ?) "]") #SquareBrackets) #TempVars ":" (IfConvRule()| SimpleStatement())+#Rules < END >}void ForEachStatement():{  Token t;}{  (    < FOREACH >    {      int argCounter = 1;    }    (      < KEY > #Key    | < TAG > #Tag    | < VAR > #Var)    (t = < IDENTIFIER >    {      jjtThis.val = t.image;      argCounter++;    }    #Elem)? #Iter(argCounter)  < IN >  (    (      t = < IDENTIFIER >      {        jjtThis.val = t.image;      }    |      (        (          < PROGRAM > #Program        | < FUNCTION > #Function)        (          "=" SetOfJPs() #Equals)?      )      (        ":" SetOfJPs() #Colons)?    )?    (      "{" JPList() #List "}")?  ) #IterList < DO >  {    int instCounter = 0;  }  ((Insert()| Set()) (< DEPENDENT > ":" (DependentStmt()) + < END >) ?)+#Body < END >)}void Insert() :{}{  < INSERT > "."  (    < BEFORE > #Before  | < AFTER > #After  | < AROUND > #Around)  {    int argCounter = 1;  }  (    "."    (      < END > #End    | < BEGIN > #Begin)    {      argCounter++;    }  )?  #Args(argCounter)":"(  TargetCode() #Body)+}void Set() #void :{  Token t;}{  < SET >  (    (      t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Lhs "=" (("{" Identifier() ("," Identifier()) * "}")    | Types()    | t = < IDENTIFIER >      {        jjtThis.val = t.image;      }    ) #Rhs) #Set| (< FIXED > "=" "{" FixedPointProperties() "=" ValuesFixedPointProperties() #Set(2) ("," FixedPointProperties() "=" ValuesFixedPointProperties() #Set(2)) * "}") #SetFixed)";"}void WithStatement() :{  Token t;}{  < WITH >  (    (      (        (          < FUNCTION > "=" t = < IDENTIFIER >          {            jjtThis.val = t.image;          }          #Function        | < MODULE > "=" t = < IDENTIFIER >          {            jjtThis.val = t.image;          }          #Module)      )      (        (          < DO >          (            Statement()            (              < DEPENDENT > ":"              (                DependentStmt()              )+              < END >            )?          )+          #Do < END >)      |        (          (            ","            (              (< CALL > "=" t = < IDENTIFIER >)              {                jjtThis.val = t.image;              }              #Call            | (< OPERATION > "=" OpsForConfigRules()) #Operation)        )?        (          < USE > (< CONFIGURATION > t = < IDENTIFIER >          {            jjtThis.val = t.image;          }          #Config ";")+ < END >        ) #Use)    )  )|  (    < STMT > "=" t = < STRING >    {      jjtThis.val = t.image;    }    #Statement < DO > Decompose() #Do < END >)|(  < VAR > "=" SetOfJPs() #Var < DO > (Statement())+#Do < END >))}void TargetCode() #void :{  Token t, s = null;}{  < TARGETCODE > #Targetcode| < FPRINTF > "(" Arg(){  int argCounter = 1;}(  "," Arg()  {    argCounter++;  })*")" ";" #Fprintf(argCounter)| t = < IDENTIFIER >(  (    Param(t)    "="    (      (        t = < IDENTIFIER > Param(t)        {          jjtThis.val = t.image;        }        s = Op() t = < NUMBER >        {          jjtThis.val = t.image;        }        #Number)      {        jjtThis.val = s.image;      }      #Op(2)    ";"  | (t = < NUMBER >)    {      jjtThis.val = t.image;    }    #Number ";")) #Assignment(2)|{  argCounter = 0;}(  "("  (    {      argCounter++;    }    Arg()    (      "," Arg()      {        argCounter++;      }    )*  )?  ")" ";"){  jjtThis.val = t.image;}#Method(argCounter))| < PRINT > "("{  argCounter = 2;}(  < SCREEN >  {	jjtThis.val = "screen";
  } #Arg| (< FILE > ":" ((t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Lhs "." t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Rhs) #FileId(2)| (t = < QUOTED >)  {    jjtThis.val = t.image;  }  #Quoted)) #File(1))"," Arg()(  "," Arg()  {    argCounter++;  })*")" ";" #Print(argCounter)| < WARNING > "(" t = < QUOTED > ")" ";"{  jjtThis.val = t.image;}#Warning}void Arg() #void :{  Token t = null;}{  t = < NUMBER >  {    jjtThis.val = t.image;  }  #Arg| t = < IDENTIFIER > (Param(t))?#Arg| t = < QUOTED > (Param(t) ":" < QUOTED >)?{  jjtThis.val = t.image;}#Arg| Param(t){  int counter = 1;}(":" t = < QUOTED >{  jjtThis.val = t.image;  counter = 2;}#Colons)? #Arg(counter)| "\'" Param(t){  counter = 1;}(":" t = < QUOTED >{  jjtThis.val = t.image;  counter = 2;}#Colons)? "\'" #Arg(counter)}void Param(Token s) #void :{  Token t1, t2 = null;}{{	int number = 1;
}  (    "<"  (    < KEY > #Key  | t1 = < IDENTIFIER >    {      jjtThis.val = t1.image;    }    #Identifier  | < VAR > #Var)  ("." t2 = < IDENTIFIER >  {    jjtThis.val = t2.image;
    number++;  }  #Rhs)? ">"
  )  {	if (s != null) jjtThis.val = s.image;
  } #Param(number)}Token Op() #void :{  Token t;}{  t = "+"  {    return t;  }| t = "-"  {    return t;  }}void Types() #void :{}{  < INT8 > #Int8| < INT16 > #Int16| < INT32 > #Int32| < UINT8 > #UInt8| < UINT16 > #UInt16| < UINT32 > #UInt32| < CHAR > #Char| < BOOL > #Bool| < DOUBLE > #Double| < SINGLE > #Single| Fixed()}void OpsForConvRules() #void :{  Token t;}{  t = < STRING >  {    jjtThis.val = t.image;  }  #Operation}void TypesOnCOnvRules() #void :{}{  (    Types()  | < FLOAT > #Float  | < INT > #Int)}void IfConvRule() #If :{  Token t;}{  < IF >  (    "("    (      < LHS > #Lhs    | CompleteIdentifier()  ) #LeftOp  {}  (t = ">="| t = "<="| t = ">"| t = "<"| t = "=="| t = "!=")(  CompleteIdentifier()| BuiltInFunctions() "("  (    CompleteIdentifier()    (      "," CompleteIdentifier()    )*  )?  ")") #RightOp ")"){  jjtThis.val = t.image;}#Condition(2)(  SimpleStatement()| IfConvRule())+#Body{}(< ELSE > (SimpleStatement()| IfConvRule()) + #Else)?< END >}void SimpleStatement() #void :{}{  (    < IR > "="    (      < LHS > #Lhs    | BuiltInFunctions()    "("    (      CompleteIdentifier()      (        "," CompleteIdentifier()      )*    )?    ")"  | CompleteIdentifier()  )  ";") #Ir| (CompleteIdentifier() #LeftOp "=" ((CompleteIdentifier()| BuiltInFunctions() "(" (CompleteIdentifier() ("," CompleteIdentifier()) *) ? ")") ((< OR > #Or| < AND > #And| < XOR > #Xor| "*" #Mul| "+" #Sum| "-" #Sub) (CompleteIdentifier()| BuiltInFunctions() "(" (CompleteIdentifier() ("," CompleteIdentifier()) *) ? ")")) ?) #RightOp ";") #Assignment}void FixedPointProperties() #void :{}{  < OVERFLOW > #Overflow| < ROUND > #Round}void ValuesFixedPointProperties() #void :{}{  < WRAP > #Wrap| < FLOOR > #Floor}void SetOfJPs() #void :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Elem| ("{" (Identifier() ("," Identifier()) *) "}")}void Identifier() #void :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Elem}void JPList() #void :{}{  JP()  (    "," JP()  )*}void JP() #void :{  Token t;}{  (    (      ("@")? t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Elem)  | < END > #End  | < IF > #If  | < ELSE > #Else)}void DependentStmt() :{  Token t;}{  < FOREACH >  {    int argCounter = 1;  }  (    < KEY > #Key  | < TAG > #Tag  | < VAR > #Var)  (t = < IDENTIFIER >  {    jjtThis.val = t.image;    argCounter++;  }  #Elem)? #Iter(argCounter)< IN >(  (    < IDENTIFIER >  |    (      (        < PROGRAM > #Program      | < FUNCTION > #Function)      (":" t = < IDENTIFIER >      {        jjtThis.val = t.image;      }      #Colons)?    )  )| "{" JPList() #List "}") #IterList < DO > ((Insert()| Set()) +)< END >}void OpsForConfigRules() #void :{  Token t;}{  t = < STRING >  {    jjtThis.val = t.image;  }  #OpsConfigRules}void Decompose():{  Token t;}{  < DECOMPOSE > t = < TARGETCODE >  {    jjtThis.val = t.image;  }  #TargetCode ";"}void Fixed():{}{  < FIXED >  (    "<" Number() "," Number() "," Number() ">"  )?}void Number() :{  Token t;}{  t = < NUMBER >  {    jjtThis.val = t.image;  }}void CompleteIdentifier() #Ident :{  Token t;}{  t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Left  {}  ("." (t = < IDENTIFIER >  {    jjtThis.val = t.image;  }  #Right| BuiltInFunctions() #Right)  {})?}void BuiltInFunctions() #void :{}{  < MAX > #Max| < MIN > #Min}